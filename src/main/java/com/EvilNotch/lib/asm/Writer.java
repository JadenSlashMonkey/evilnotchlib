package com.EvilNotch.lib.asm;

import org.objectweb.asm.ByteVector;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;

public class Writer extends ClassWriter
{
	 public Writer(final int flags) 
	 {
		super(flags); 
	 }
	
	  public Writer(final ClassReader classReader, final int flags) 
	  {
		  super(classReader,flags);
	  }
	  
	  /**
	     * Returns the common super type of the two given types. The default
	     * implementation of this method <i>loads</i> the two given classes and uses
	     * the java.lang.Class methods to find the common super class. It can be
	     * overridden to compute this common super type in other ways, in particular
	     * without actually loading any class, or to take into account the class
	     * that is currently being generated by this ClassWriter, which can of
	     * course not be loaded since it is under construction.
	     * 
	     * @param type1
	     *            the internal name of a class.
	     * @param type2
	     *            the internal name of another class.
	     * @return the internal name of the common super class of the two given
	     *         classes.
	     */
	  /**
	     * Returns the common super type of the two given types. The default
	     * implementation of this method <i>loads</i> the two given classes and uses
	     * the java.lang.Class methods to find the common super class. It can be
	     * overridden to compute this common super type in other ways, in particular
	     * without actually loading any class, or to take into account the class
	     * that is currently being generated by this ClassWriter, which can of
	     * course not be loaded since it is under construction.
	     * 
	     * @param type1
	     *            the internal name of a class.
	     * @param type2
	     *            the internal name of another class.
	     * @return the internal name of the common super class of the two given
	     *         classes.
	     */
	  //TODO do it in a way that doesn't load the class
	  @Deprecated
	  @Override
	  protected String getCommonSuperClass(final String type1, final String type2) 
	  { 
		  if(type1.contains("BlockPos")||type2.contains("BlockPos"))
		  {
			  return "net/minecraft/util/math/BlockPos";
		  }
		  else if(type1.contains("java/lang/Object")||type2.contains("java/lang/Object"))
		  {
			  return "java/lang/Object";
		  }
		  
	      Class<?> c, d;
	      ClassLoader classLoader = getClass().getClassLoader();
	        try {
	            c = Class.forName(type1.replace('/', '.'), false, classLoader);
	            d = Class.forName(type2.replace('/', '.'), false, classLoader);
	        } catch (Exception e) {
	        	System.out.println("ERROR");
	        	System.out.println(type1);
	        	System.out.println(type2);
	            throw new RuntimeException(e.toString());
	        }
	        if (c.isAssignableFrom(d)) {
	            return type1;
	        }
	        if (d.isAssignableFrom(c)) {
	            return type2;
	        }
	        if (c.isInterface() || d.isInterface()) {
	            return "java/lang/Object";
	        } else {
	            do {
	                c = c.getSuperclass();
	            } while (!c.isAssignableFrom(d));
	            return c.getName().replace('.', '/');
	        }
	    }
}
